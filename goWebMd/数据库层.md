# 连接使用MySQL数据库

## 

**使用go语言中原生SQL包，从数据库中根据用户id查找用户的用户名密码邮箱等用户信息并绑定给后端中user这一元素**

```go
package main

import (
    "database/sql"
    "fmt"
    _ "github.com/go-sql-driver/mysql" // MySQL驱动，下划线表示只初始化不直接调用
)

// 定义后端User结构体，与数据库用户表字段对应
type User struct {
    ID       int    // 用户ID（主键）
    Username string // 用户名
    Password string // 密码（实际项目要存加密串，别存明文）
    Email    string // 邮箱
}

func main() {
    // 1. 数据库连接（替换成你的数据库配置：用户名:密码@tcp(地址:端口)/数据库名）
    db, err := sql.Open("mysql", "root:123456@tcp(127.0.0.1:3306)/test_db")
    if err != nil {
        fmt.Printf("数据库连接失败：%v\n", err)
        return
    }
    defer db.Close() // 函数结束前关闭连接

    // 校验连接是否可用（open只是初始化，不真正连数据库）
    if err = db.Ping(); err != nil {
        fmt.Printf("数据库ping失败：%v\n", err)
        return
    }

    // 2. 根据用户ID查询用户信息（核心逻辑）
    targetUserID := 1 // 要查询的目标用户ID
    var user User     // 用于绑定查询结果的User变量
    querySql := "SELECT id, username, password, email FROM user WHERE id = ?" // ?是占位符，防SQL注入

    // 关键：Scan方法绑定字段到User结构体，字段顺序必须和SQL查询顺序完全一致
    err = db.QueryRow(querySql, targetUserID).Scan(&user.ID, &user.Username, &user.Password, &user.Email)
    if err != nil {
        if err == sql.ErrNoRows {
            fmt.Printf("未找到ID为%d的用户\n", targetUserID)
            return
        }
        fmt.Printf("查询用户失败：%v\n", err)
        return
    }

    // 3. 查询成功，user已绑定完整信息
    fmt.Println("查询到的用户信息：")
    fmt.Printf("ID：%d\n用户名：%s\n邮箱：%s\n", user.ID, user.Username, user.Email)
}
```

## 

**更新符合条件的用户的用户信息** 

```sql
	// 2. 执行更新SQL（update 表名 set 字段=值 where 条件，where必加！避免全表更新）
	res, err := db.Exec("UPDATE user SET age=25 WHERE id=?"userID)
	if err != nil {
		fmt.Println("更新失败：")
		return err
	}
	// 3. 获取受影响行数（可选，验证是否更新成功）
	rowsAffected, _ := res.RowsAffected()
	fmt.Printf("成功更新 %d 条数据\n", rowsAffected)
```

##  

**分页逻辑**

```go
package main

import (
	"database/sql"
	"fmt"
	"log"

	_ "github.com/go-sql-driver/mysql"
)

// Book 定义书籍结构体，对应数据库表字段
type Book struct {
	ID     int    // 书籍ID
	Name   string // 书籍名
	Author string // 作者名
	Price  float64// 价格（示例字段，可根据实际表结构调整）
	Press  string // 出版社（示例字段）
}

// 数据库连接配置
const (
	username = "root"       // 数据库用户名
	password = "your_password" // 数据库密码
	host     = "127.0.0.1"  // 数据库地址
	port     = "3306"       // 端口
	dbName   = "test_db"    // 数据库名
)

// getDB 获取数据库连接
func getDB() (*sql.DB, error) {
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
		username, password, host, port, dbName)
	db, err := sql.Open("mysql", dsn)
	if err != nil {
		return nil, err
	}
	// 验证连接
	if err := db.Ping(); err != nil {
		return nil, err
	}
	// 设置连接池参数（可选，优化性能）
	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(5)
	return db, nil
}

// SearchBooksWithWang 分页查询书名/作者含“王”的书籍
// page: 当前页（从1开始），pageSize: 每页条数
func SearchBooksWithWang(page, pageSize int) ([]Book, int, error) {
	db, err := getDB()
	if err != nil {
		return nil, 0, fmt.Errorf("数据库连接失败：%v", err)
	}
	defer db.Close() // 函数结束关闭连接

	// 1. 查询符合条件的总条数（用于计算总页数）
	var total int
	countSQL := `SELECT COUNT(*) FROM books WHERE name LIKE ? OR author LIKE ?`
	// 参数化查询，防止SQL注入，%是模糊匹配通配符
	err = db.QueryRow(countSQL, "%王%", "%王%").Scan(&total)
	if err != nil {
		return nil, 0, fmt.Errorf("查询总条数失败：%v", err)
	}

	// 2. 计算分页偏移量（OFFSET从0开始，所以page-1）
	offset := (page - 1) * pageSize
	// 3. 分页查询书籍列表
	querySQL := `
		SELECT id, name, author, price, press 
		FROM books 
		WHERE name LIKE ? OR author LIKE ? 
		LIMIT ? OFFSET ?
	`
	rows, err := db.Query(querySQL, "%王%", "%王%", pageSize, offset)
	if err != nil {
		return nil, 0, fmt.Errorf("查询书籍列表失败：%v", err)
	}
	defer rows.Close() // 关闭结果集

	// 4. 解析查询结果到Book切片
	var books []Book
	for rows.Next() {
		var book Book
		err := rows.Scan(&book.ID, &book.Name, &book.Author, &book.Price, &book.Press)
		if err != nil {
			return nil, 0, fmt.Errorf("解析书籍数据失败：%v", err)
		}
		books = append(books, book)
	}
	// 检查遍历结果集时的错误
	if err := rows.Err(); err != nil {
		return nil, 0, fmt.Errorf("遍历结果集失败：%v", err)
	}

	return books, total, nil
}

func main() {
	// 示例：查询第1页，每页10条
	page := 1
	pageSize := 10

	books, total, err := SearchBooksWithWang(page, pageSize)
	if err != nil {
		log.Fatalf("查询失败：%v", err)
	}

	// 输出结果
	fmt.Printf("共查询到 %d 本含“王”的书籍\n", total)
	fmt.Printf("第 %d 页（每页 %d 条）：\n", page, pageSize)
	for _, book := range books {
		fmt.Printf("ID：%d，书名：%s，作者：%s，价格：%.2f，出版社：%s\n",
			book.ID, book.Name, book.Author, book.Price, book.Press)
	}

	// 计算总页数（可选）
	totalPage := (total + pageSize - 1) / pageSize
	fmt.Printf("总页数：%d\n", totalPage)
}
```

